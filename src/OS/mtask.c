#include "mtask.h"
#include "timer.h"
#include "naskfunc.h"
#include "memory.h"
#include "dsctbl.h"

struct TASKCTL *taskctl;
struct TIMER *task_timer;
	
struct TASK *task_init(struct MEMMAN *memman)
{
  int i;
  struct TASK *task;
  struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
  taskctl = (struct TASKCTL *)memman_alloc_4k(memman, sizeof(struct TASKCTL));
  
  //初始化GDT TSS
  for (i = 0; i < MAX_TASKS; i++) {
    taskctl->tasks0[i].flags = 0;
    taskctl->tasks0[i].sel = (TASK_GDT0 + i) * 8;
    set_segmdesc(gdt+TASK_GDT0+i, 103, (int)&taskctl->tasks0[i].tss, AR_TSS32);
  }

  task = task_alloc();//分配一个任务给当前
  task->flags = 2;//运行状态，活动中
  task->priority = 2;//0.02s
  taskctl->running = 1;
  taskctl->now = 0;
  taskctl->tasks[0] = task;
  load_tr(task->sel);
  task_timer = timer_alloc();//分配task切换timer
  timer_settime(task_timer, task->priority);//设置任务切换时间,并且应用优先级
  
  return task;
}

struct TASK *task_alloc(void)
{
  int i;

  struct TASK *task;
  for (i = 0; i < MAX_TASKS; i++) {
    if (taskctl->tasks0[i].flags == 0) {//未使用的task结构
      taskctl->tasks0[i].flags = 1;//已分配状态
      task = &taskctl->tasks0[i];
      task->tss.eflags = 0x00000202;//IF=1
      task->tss.eax = 0;
      task->tss.ecx = 0;
      task->tss.edx = 0;      
      task->tss.ebx = 0;
      task->tss.ebp = 0;
      task->tss.esi = 0;
      task->tss.edi = 0;
      task->tss.es = 0;
      task->tss.ds = 0;
      task->tss.fs = 0;
      task->tss.gs = 0;
      task->tss.ldtr = 0;      
      task->tss.iomap = 0x40000000;
      return task;
    }
  }
  return 0;
}

void task_run(struct TASK *task, int priority)
{
  if (priority > 0) {
    task->priority = priority;
  }

  if (task->flags != 2) {//如果不是运行状态才...,可以只是改变优先级
    task->flags = 2;//置为运行状态
    taskctl->tasks[taskctl->running] = task;
    taskctl->running++;//运行任务数加1
  }
  return;
}

void task_switch(void)
{
  struct TASK *task;
  taskctl->now++;
  if (taskctl->now == taskctl->running) {//如果是最后一个，下次就选择第一个task
    taskctl->now = 0;//轮询运行
  }
  task = taskctl->tasks[taskctl->now];
  timer_settime(task_timer, task->priority);//重写task timer
 
  if (taskctl->running >= 2) {//超过一个任务运行
    farjmp(0, task->sel);
  }
  return ;
}


void task_sleep(struct TASK *task)
{
  int i;
  char ts = 0;
  if (task->flags == 2) {//如果指定的任务处于运行状态
    if (task == taskctl->tasks[taskctl->now]) {//如果睡眠的是当前的task,需要进行任务切换
      ts = 1;
    }
    //寻找task的位置
    for (i = 0; i < MAX_TASKS; i++) {
      if (task == taskctl->tasks[i]) {
	break;
      }
    }
    taskctl->running--;
    if (i < taskctl->now) {
      taskctl->now--;
    }
    //移动成员
    for (; i < taskctl->running; i++) {
      taskctl->tasks[i] = taskctl->tasks[i+1];
    }
    task->flags = 1;//置为不运行状态
    if (ts != 0) {
      //任务切换
      if (taskctl->now >= taskctl->running) {//异常，修正
	taskctl->now = 0;
      }
      farjmp(0, taskctl->tasks[taskctl->now]->sel);
    }
  }
  return;
}
